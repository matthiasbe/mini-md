\documentclass[11pt,a4paper]{article}


\setlength{\topmargin}{-55pt}%
\setlength{\oddsidemargin}{-20pt}%
\setlength{\textwidth}{490pt}%
\setlength{\textheight}{700pt}%
\setlength{\headsep}{20pt}%
\setlength{\headheight}{14pt}

\usepackage[utf8]{inputenc} % accents 8 bits dans le fichier
\usepackage[T1]{fontenc}      % accents codés dans la fonte
\usepackage[french]{babel}
\usepackage{amsmath,amssymb}
\usepackage{graphicx}
\usepackage{fancyhdr}
\usepackage{booktabs}
\usepackage{color, colortbl}
\usepackage{appendix}
\usepackage{pgfplots}
\usepackage[hidelinks]{hyperref}
\usepackage{siunitx}
\usepackage{subcaption}

\pgfplotsset{compat=1.3}

\addto\captionsfrench{% Replace "english" with the language you use
  \renewcommand{\contentsname}%
    {Table des matières}
}

\DecimalMathComma

\lhead{}      %en-tête
\chead{AOC : Application MiniMD}%
\rhead{}%
\lfoot{\tiny{Pierre GRANGER \& Matthias BEAUPERE}}
\cfoot{}%
\rfoot{\thepage}%
\renewcommand{\headrulewidth}{0.5pt}
\renewcommand{\footrulewidth}{0.5pt}
\pagestyle{fancy}

\newcommand{\HRule}{\rule{\linewidth}{0.5mm}}
\newcommand{\norm}[1]{\left\lVert#1\right\rVert}

\definecolor{green}{rgb}{0.2,0.8,0.2}

\begin{document}
\begin{center}

	{\LARGE\centering Projet d'AOC :\\ Application de test MiniMD}\\[1cm]

	{ Matthias \bsc{Beaupère}, Pierre \bsc{Granger}}\\[0.5cm]
	{Rapport AOC - CHPS - \today}\\[2cm]
\end{center}

\tableofcontents
\newpage

\section{Présentation de l'application}
	L'application sur laquelle nous avons travaillé est MiniMD. Cette application de simulation en dynamique moléculaire est écrite en C++ et est parallèle. Son objectif est de pouvoir tester l'efficacité des nouvelles architectures parallèles dans l'exécution de codes de simulation de dynamique moléculaire. Dans cet objectif, cette mini-application a été conçue afin d'être simple et légère ainsi que facilement adaptable sur de nouvelles architectures matérielles. Les algorithmes de base utilisés dans ce code suivent les algorithmes d'un code de dynamique moléculaire de production bien plus important, LAMMPS.

	L'application est écrite en C++ et comporte moins de 5000 lignes de code. Elle permet d'effectuer des simulations de dynamique moléculaire avec des potentiels de Lennard-Jones ou des modèles EAM (Emnbedded Atom Model) uniquement. La parallélisation des calculs est effectuée via une décomposition spatiale du domaine d'étude : chaque processeur du cluster effectue ses calculs sur une partie du domaine de simulation. Le code est sensé passer correctement à l'échelle  sur une architecture parallèle. L'application peut fonctionner avec plusieurs librairies de parallélisation proposant des types de paralllisme différents : MPI, OpenMP, OpenCL, Kokkos, OpenACC, ... Dans ce rapport, seule l'implémentation utilisant MPI pour le prallélisme en mémoire distribuée et OpenMP pour le parallélisme en mémoire partagée sera étudiée.

	Comme dans des codes de simulations plus complexes, miniMD permet à l'utilisateur de spécifier de nombreux paramètres du problèmes à étudier : la taille du problème, la température, la densité atomique, la durée des pas de temps, le nombre de pas de temps à simuler et la distance de coupure à utiliser pour l'intéraction considérée. Néanmoins, seuls deux types d'interactions sont disponibles (Lennard-Jones et EAM). En effet, les intéractions électrostatiques à longue distance ainsi que les champs de force moléculaires ne peuvent pas être simulés avec cette application. L'ajout de telles fonctionnalités n'aurait fait que compliquer le code alors qu'elles ne sont pas nécessaires afin d'effectuer des tests avec de la dynamique moléculaire basique. Avec ses fonctionnalités limités, miniMD permet à des personnes n'étant pas des experts de la dynamique moléculaire d'effectuer des tests de performance à l'aide de ce code.

	Afin d'optimiser les calculs de forces ressenties par chaque atome, miniMD utilise des listes d'atomes voisins tout comme la majorité des codes de dynamique moléculaire actuels. Cette technique a l'inconvénient d'utiliser plus de mémoire, c'est à dire environ 1GB pour 500000 atomes simulés.

	Dans sa dernière version, miniMD offre la possibilité de simulés des atomes de nature différente ce qui n'était pas le cas dans sa première version. Cette fonctionnalité, qui permet de mieux modéliser le comportement d'un code de dynamique moléulaire de production, dégrade les performances par rapport à la version initiale. En effet, l'introduction de plusieurs types d'atomes ajoute des indirections au sein du code ce qui le ralentit et diminue les possibilités de vectorisation de ce dernier.

	\subsection{Compilation de l'application}
		Comme expliqué précédemment, nous compilons la version utilisant MPI et OpenMP. Ses sources peuvent être trouvées dans le sous dossier \textit{ref}. Le code peut alors être simplement compilé en exécutant la commande \textit{make openmpi}. Une fois compilé, le programme peut être testé en utilisant la commande \textit{make test}. Les tests réalisés s'appuient sur des comparaisons avec des résultats précalculés et fournis avec le code source du programme.
\section{Bilan de performances}

	\subsection{Cadre d'expérimentation}
		
		\subsubsection{Matériel d'expérimentation}

			Le programme miniMD est compilé puis exécuté sur un PC de bureau sous Linux Mint ayant 8 Go de mémoire vive et un processeur Intel I3 2.8 GHz de première génération. Ce processeur a une micro-architecture de type Nehalem qui à une vectorisation SSE 4.2. Une telle architecture permet d'effectuer des opérations sur des blocs de 128 bits.

		\subsubsection{Compilation}

			Le programme est compilé avec \texttt{gcc} version 5.4 ainsi que les options \texttt{-Ofast} activant les optimisations du compilateur et \texttt{--funroll-loops} qui optimise le déroulement des boucles. L'option \texttt{-g} est également présente pour pouvoir effectuer le profiling.

		\subsubsection{Exécution et profiling}

			La mini-app permet un paramétrage fin du problème physique sous-jacent. Nous avons ainsi pu dimensionner le problème pour avoir un temps d'exécution d'environ 40 secondes sur la machine présentée plus haut, ce qui conduit à la génération d'un million d'atomes.

			La mini-app est exécutée à travers un profiler, ce qui permet de générer un bilan de performances pour un exécution de l'application. Nous avons choisi le profiler Maqao qui permet de visualiser les points chauds et donne des conseils d'optimisation utiliser pleinement les performances de la micro-architecture.

	\subsection{Résultats}

		\subsubsection{}

\section{Optimisations}

\end{document}
